/*
 * Copyright (c) 2016 Motorola Mobility, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holder nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#define DEBUG
#define DEBUG_DUMP_REGISTER

#include <nuttx/config.h>

#include <errno.h>
#include <debug.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <nuttx/device_cam_ext.h>
#include <nuttx/gpio.h>
#include <nuttx/device.h>
#include <nuttx/mhb/mhb_protocol.h>
#include <nuttx/mhb/mhb_csi_camera.h>
#include <nuttx/camera/camera_ext_defs.h>
#include <nuttx/device_mhb_cam.h>
#include <nuttx/math.h>
#include <nuttx/camera/camera_ext_meta.h>
#include <nuttx/camera/camera_ext.h>

struct dev_private_s
{
    uint8_t rst_n;
    uint8_t dvdd_en;
    uint8_t areg_en;
    uint8_t spi_sel;
};

struct dev_private_s s_data;

#define CAMERA_POWER_DELAY_US (100000)
#define CAMERA_SENSOR_I2C_ADDR 0x1a

/*
 * This is the MHB(Mods Hi-Speed Bus) camera driver for
 * Sony IMS220 raw sensor
 *
 */

#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))

struct cam_i2c_reg_array {
    const uint16_t reg_addr;
    const uint8_t data;
};

struct cam_i2c_reg_setting {
    const uint16_t size;
    struct cam_i2c_reg_array const *regs;
};

static const struct cam_i2c_reg_array init_reg_array[] = {
    /* External Clock Settings - 19.2*/
    { 0x0136, 0x13 },
    { 0x0137, 0x02 },
    /* Global Settings */
    { 0x3004, 0x07 },
    { 0x31CE, 0x01 },
    { 0x4011, 0x02 },
    { 0x4012, 0x04 },
    { 0x4013, 0x04 },
    { 0x40C4, 0x00 },
    { 0x4119, 0xFB },
    { 0x412A, 0x01 },
    { 0x412B, 0x0B },
    { 0x412E, 0x00 },
    { 0x412F, 0x2D },
    { 0x4132, 0x00 },
    { 0x4133, 0x46 },
    { 0x4136, 0x00 },
    { 0x4137, 0x34 },
    { 0x4138, 0x00 },
    { 0x4139, 0xC7 },
    { 0x413A, 0x00 },
    { 0x413B, 0x0A },
    { 0x452B, 0x00 },
    { 0x452c, 0x01 },
    { 0x4532, 0x05 },
    { 0x45AC, 0x00 },
    { 0x45BF, 0x00 },
    { 0x4624, 0x03 },
    { 0x462F, 0x00 },
    { 0x4630, 0x01 },
    { 0x4637, 0x00 },
    { 0x4738, 0x00 },
    { 0x473d, 0x01 },
    { 0x474E, 0x00 },
    { 0x4754, 0x01 },
    { 0x4757, 0x08 },
    { 0x475a, 0x00 },
    { 0x475B, 0x00 },
    { 0x4770, 0x0E },
    { 0x4777, 0x04 },
    { 0x479C, 0x20 },
    { 0x47DC, 0x00 },
    { 0x47DD, 0xC5 },
    { 0x47DE, 0x00 },
    { 0x47DF, 0x44 },
    { 0x4800, 0x0E },
    { 0x4804, 0x0E },
    { 0x4808, 0x0E },
    { 0x480C, 0x0E },
    { 0x4810, 0x0D },
    { 0x4818, 0x0D },
    { 0x4843, 0x08 },
    { 0x488E, 0x03 },
    { 0x488F, 0x03 },
    { 0x4890, 0x01 },
    { 0x48CF, 0x3F },
    { 0x48D3, 0x3F },
    { 0x48D7, 0x3F },
    { 0x48DB, 0x3F },
    { 0x48DF, 0x3F },
    { 0x48E3, 0x3F },
    { 0x4968, 0x01 },
    { 0x496F, 0x00 },
    { 0x4970, 0x00 },
    { 0x4971, 0x9E },
    { 0x4972, 0x00 },
    { 0x4973, 0x37 },
    { 0x4974, 0x01 },
    { 0x497B, 0x00 },
    { 0x497C, 0x00 },
    { 0x497D, 0x84 },
    { 0x497E, 0x00 },
    { 0x497F, 0x2E },
    { 0x4980, 0x01 },
    { 0x4987, 0x00 },
    { 0x4988, 0x00 },
    { 0x4989, 0x71 },
    { 0x498A, 0x00 },
    { 0x498B, 0x27 },
    { 0x498C, 0x01 },
    { 0x4993, 0x00 },
    { 0x4994, 0x00 },
    { 0x4995, 0x63 },
    { 0x4996, 0x00 },
    { 0x4997, 0x22 },
    { 0x4998, 0x01 },
    { 0x499F, 0x00 },
    { 0x49A0, 0x00 },
    { 0x49A1, 0x58 },
    { 0x49A2, 0x00 },
    { 0x49A3, 0x1F },
    { 0x49A4, 0x01 },
    { 0x49AB, 0x00 },
    { 0x49AC, 0x00 },
    { 0x49AD, 0x4F },
    { 0x49AE, 0x00 },
    { 0x49AF, 0x1C },
    { 0x4D1E, 0x00 },
    { 0x4D1F, 0x79 },
    { 0x4DA0, 0x01 },
    { 0x4DA1, 0x0A },
    { 0x4E8C, 0x01 },
    { 0x4E8D, 0x31 },
    { 0x4E8E, 0x01 },
    { 0x4E8F, 0x35 },
    { 0x4EF2, 0x01 },
    { 0x4EF3, 0x02 },
    { 0x4EF6, 0x00 },
    { 0x4EF7, 0x83 },
    { 0x61C3, 0x78 },
    { 0x627F, 0x3C },
    { 0x62B3, 0x00 },
    { 0x6975, 0x02 },
    { 0x6978, 0x03 },
    { 0x6979, 0x00 },
    { 0x697C, 0x03 },
    { 0x697F, 0x02 },
    { 0x6980, 0x13 },
    { 0x6981, 0x00 },
    { 0x6984, 0x13 },
    { 0x6987, 0x01 },
    { 0x6988, 0x0C },
    { 0x6989, 0x09 },
    { 0x698C, 0x0C },
    { 0x698F, 0x01 },
    { 0x6990, 0x1C },
    { 0x6991, 0x09 },
    { 0x6994, 0x1C },
    { 0x6997, 0x02 },
    { 0x6998, 0x01 },
    { 0x6999, 0x14 },
    { 0x699B, 0x01 },
    { 0x699C, 0x01 },
    { 0x699F, 0x01 },
    { 0x69A0, 0x11 },
    { 0x69A1, 0x14 },
    { 0x69A3, 0x02 },
    { 0x69A4, 0x11 },
    { 0x69A7, 0x02 },
    { 0x69A8, 0x0A },
    { 0x69A9, 0x1D },
    { 0x69AB, 0x02 },
    { 0x69AC, 0x0A },
    { 0x69AF, 0x02 },
    { 0x69B0, 0x1A },
    { 0x69B1, 0x1D },
    { 0x69B3, 0x01 },
    { 0x69B4, 0x1A },
    { 0x69B7, 0x01 },
    { 0x69BB, 0x01 },
    { 0x69BC, 0x05 },
    { 0x69BD, 0x05 },
    { 0x69C1, 0x00 },
    { 0x69C4, 0x01 },
    { 0x69C6, 0x01 },
    { 0x7B4A, 0x02 },
    { 0x7B4D, 0x03 },
    { 0x7B4E, 0x00 },
    { 0x7B51, 0x03 },
    { 0x7B52, 0x02 },
    { 0x7B53, 0x02 },
    { 0x7B55, 0x13 },
    { 0x7B56, 0x00 },
    { 0x7B59, 0x13 },
    { 0x7B5A, 0x02 },
    { 0x7B5B, 0x01 },
    { 0x7B5D, 0x0C },
    { 0x7B5E, 0x09 },
    { 0x7B61, 0x0C },
    { 0x7B62, 0x0B },
    { 0x7B63, 0x01 },
    { 0x7B65, 0x1C },
    { 0x7B66, 0x09 },
    { 0x7B69, 0x1C },
    { 0x7B6A, 0x0B },
    { 0x7B6B, 0x02 },
    { 0x7B6D, 0x01 },
    { 0x7B6E, 0x14 },
    { 0x7B6F, 0x01 },
    { 0x7B71, 0x01 },
    { 0x7B72, 0x16 },
    { 0x7B73, 0x01 },
    { 0x7B75, 0x11 },
    { 0x7B76, 0x14 },
    { 0x7B77, 0x02 },
    { 0x7B79, 0x11 },
    { 0x7B7A, 0x16 },
    { 0x7B7B, 0x02 },
    { 0x7B7D, 0x0A },
    { 0x7B7E, 0x1D },
    { 0x7B7F, 0x02 },
    { 0x7B81, 0x0A },
    { 0x7B82, 0x1F },
    { 0x7B83, 0x02 },
    { 0x7B85, 0x1A },
    { 0x7B86, 0x1D },
    { 0x7B87, 0x01 },
    { 0x7B89, 0x1A },
    { 0x7B8A, 0x1F },
    { 0x7B8B, 0x01 },
    { 0x9009, 0x02 },
    { 0x900A, 0x34 },
    { 0xB040, 0x50 },
    { 0xB041, 0x3E },
    { 0xB042, 0x50 },
    { 0xB043, 0x3F },
    { 0xB080, 0x6E },
    { 0xB081, 0x44 },
    { 0xB082, 0x6E },
    { 0xB083, 0x45 },
    { 0xB084, 0x6E },
    { 0xB085, 0x46 },
    { 0xB086, 0x6E },
    { 0xB087, 0x47 },
    { 0xB088, 0xAA },
    { 0xB089, 0x1E },
    { 0xB08A, 0xAA },
    { 0xB08B, 0x1F },
    { 0xB08C, 0xAA },
    { 0xB08D, 0x20 },
    { 0xB08E, 0xAA },
    { 0xB08F, 0x21 },
    { 0xB090, 0xAA },
    { 0xB091, 0x22 },
    { 0xB092, 0xAA },
    { 0xB093, 0x23 },
    { 0xB094, 0xAA },
    { 0xB095, 0x24 },
    { 0xB096, 0xAA },
    { 0xB097, 0x25 },
    { 0xB098, 0xAA },
    { 0xB099, 0x26 },
    { 0xB09A, 0xAA },
    { 0xB09B, 0x27 },
    { 0xB09C, 0xAA },
    { 0xB09D, 0x28 },
    { 0xB09E, 0xAA },
    { 0xB09F, 0x29 },
    { 0xB0A0, 0xAA },
    { 0xB0A1, 0x2A },
    { 0xB0A2, 0xAA },
    { 0xB0A3, 0x2B },
    { 0xB0A4, 0xAA },
    { 0xB0A5, 0x2C },
    { 0xB0A6, 0xAA },
    { 0xB0A7, 0x2D },
    { 0xB0A8, 0xAA },
    { 0xB0A9, 0x2E },
    { 0xB0AA, 0xAA },
    { 0xB0AB, 0x2F },
    { 0xB0AC, 0xAA },
    { 0xB0AD, 0x30 },
    { 0xB0AE, 0xAA },
    { 0xB0AF, 0x31 },
    { 0xB0B0, 0xAA },
    { 0xB0B1, 0x94 },
    { 0xB0B2, 0xAA },
    { 0xB0B3, 0x95 },
    { 0xB0B4, 0xAA },
    { 0xB0B5, 0x96 },
    { 0xB0B6, 0xAA },
    { 0xB0B7, 0x97 },
    { 0xB0B8, 0xAA },
    { 0xB0B9, 0x98 },
    { 0xB0BA, 0xAA },
    { 0xB0BB, 0x99 },
    { 0xB0BC, 0xAA },
    { 0xB0BD, 0x9A },
    { 0xB0BE, 0xAA },
    { 0xB0BF, 0x9B },
    { 0xB0C0, 0xAA },
    { 0xB0C1, 0x9C },
    { 0xB0C2, 0xAA },
    { 0xB0C3, 0x9D },
    { 0xB0C4, 0xAA },
    { 0xB0C5, 0x9E },
    { 0xB0C6, 0xAA },
    { 0xB0C7, 0x9F },
    { 0xB0C8, 0xAA },
    { 0xB0C9, 0xA0 },
    { 0xB0CA, 0xAA },
    { 0xB0CB, 0xA1 },
    { 0xB0CC, 0xAA },
    { 0xB0CD, 0xA2 },
    { 0xB0CE, 0xAA },
    { 0xB0CF, 0xA3 },
    { 0xB0D0, 0xAA },
    { 0xB0D1, 0xA4 },
    { 0xB0D2, 0xAA },
    { 0xB0D3, 0xA5 },
    { 0xB0D4, 0xAA },
    { 0xB0D5, 0xA6 },
    { 0xB0D6, 0xAA },
    { 0xB0D7, 0xA7 },
    { 0xB0D8, 0xAA },
    { 0xB0D9, 0xA8 },
    { 0xB0DA, 0xAA },
    { 0xB0DB, 0xA9 },
    { 0xB0DC, 0xAA },
    { 0xB0DD, 0xAA },
    { 0xB0DE, 0xAA },
    { 0xB0DF, 0xAB },
    { 0xB0E0, 0xAA },
    { 0xB0E1, 0xAC },
    { 0xB0E2, 0xAA },
    { 0xB0E3, 0xAD },
    { 0xB0E4, 0xAA },
    { 0xB0E5, 0xAE },
    { 0xB0E6, 0xAA },
    { 0xB0E7, 0xAF },
    { 0xB100, 0x4A },
    { 0xB101, 0x4A },
    { 0xB102, 0x4A },
    { 0xB103, 0x4A },
    { 0xB104, 0x4A },
    { 0xB105, 0x4A },
    { 0xB106, 0x4A },
    { 0xB107, 0x4A },
    { 0xB118, 0x08 },
    { 0xB119, 0x08 },
    { 0xB11A, 0x08 },
    { 0xB11B, 0x08 },
    { 0xB11C, 0x08 },
    { 0xB11D, 0x08 },
    { 0xB11E, 0x08 },
    { 0xB11F, 0x08 },
    { 0xB128, 0x23 },
    /* Image Quality Adjusment Settings */
    { 0x69CB, 0x01 },
    { 0x7B2B, 0x01 },
    { 0x9979, 0xE0 },
    { 0x997A, 0xE0 },
    { 0x997B, 0xE0 },
    { 0x9980, 0x00 },
    { 0x9981, 0x14 },
    { 0x9982, 0x00 },
    { 0x9983, 0x14 },
    { 0x9984, 0x00 },
    { 0x9985, 0x14 },
    { 0x99BA, 0x00 },
    { 0x99BB, 0x0A },
    { 0x99BC, 0x00 },
    { 0x99BD, 0x0A },
    { 0x99BE, 0x00 },
    { 0x99BF, 0x0A },
    { 0x99C0, 0x09 },
    { 0x99C1, 0x09 },
    { 0x99C2, 0x09 },
    { 0x9A79, 0xE0 },
    { 0x9A7A, 0xE0 },
    { 0x9A7B, 0xE0 },
    { 0x9A80, 0x00 },
    { 0x9A81, 0x14 },
    { 0x9A82, 0x00 },
    { 0x9A83, 0x14 },
    { 0x9A84, 0x00 },
    { 0x9A85, 0x14 },
    { 0x9ABA, 0x00 },
    { 0x9ABB, 0x0A },
    { 0x9ABC, 0x00 },
    { 0x9ABD, 0x0A },
    { 0x9ABE, 0x00 },
    { 0x9ABF, 0x0A },
    { 0x9AC0, 0x09 },
    { 0x9AC1, 0x09 },
    { 0x9AC2, 0x09 },
    { 0x9B79, 0xE0 },
    { 0x9B7A, 0xE0 },
    { 0x9B7B, 0xE0 },
    { 0x9B80, 0x14 },
    { 0x9B81, 0x00 },
    { 0x9B82, 0x14 },
    { 0x9B83, 0x00 },
    { 0x9B84, 0x14 },
    { 0x9B85, 0x00 },
    { 0x9BBA, 0x00 },
    { 0x9BBB, 0x0A },
    { 0x9BBC, 0x00 },
    { 0x9BBD, 0x0A },
    { 0x9BBE, 0x00 },
    { 0x9BBF, 0x0A },
    { 0x9BC0, 0x09 },
    { 0x9BC1, 0x09 },
    { 0x9BC2, 0x09 },
    { 0x9C79, 0xE0 },
    { 0x9C7A, 0xE0 },
    { 0x9C7B, 0xE0 },
    { 0x9C80, 0x00 },
    { 0x9C81, 0x14 },
    { 0x9C82, 0x00 },
    { 0x9C83, 0x14 },
    { 0x9C84, 0x00 },
    { 0x9C85, 0x14 },
    { 0x9CBA, 0x00 },
    { 0x9CBB, 0x0A },
    { 0x9CBC, 0x00 },
    { 0x9CBD, 0x0A },
    { 0x9CBE, 0x00 },
    { 0x9CBF, 0x0A },
    { 0x9CC0, 0x09 },
    { 0x9CC1, 0x09 },
    { 0x9CC2, 0x09 },
    { 0x9F64, 0xE0 },
    { 0x9F65, 0xE0 },
    { 0x9F66, 0xE0 },
    { 0x9F6A, 0x00 },
    { 0x9F6B, 0x14 },
    { 0x9F6C, 0x00 },
    { 0x9F6D, 0x14 },
    { 0x9F6E, 0x00 },
    { 0x9F6F, 0x14 },
    { 0xA064, 0xE0 },
    { 0xA065, 0xE0 },
    { 0xA066, 0xE0 },
    { 0xA06A, 0x00 },
    { 0xA06B, 0x14 },
    { 0xA06C, 0x00 },
    { 0xA06D, 0x14 },
    { 0xA06E, 0x00 },
    { 0xA06F, 0x14 },
    { 0x3129, 0x01 },
};

static const struct cam_i2c_reg_array res0_array[] = {
    /* Mode G1: 2136x1202 1080p 16:9 30 fps */
    /* Preset Settings*/
    { 0x9004, 0x00 },
    { 0x9005, 0x00 },
    /* Mode Settings*/
    { 0x0114, 0x03 },
    { 0x0220, 0x00 },
    { 0x0221, 0x11 },
    { 0x0222, 0x01 },
    { 0x0340, 0x06 },
    { 0x0341, 0x4A },
    { 0x0342, 0x17 },
    { 0x0343, 0x88 },
    { 0x0344, 0x00 },
    { 0x0345, 0x00 },
    { 0x0346, 0x01 },
    { 0x0347, 0xF8 },
    { 0x0348, 0x14 },
    { 0x0349, 0xDF },
    { 0x034A, 0x0D },
    { 0x034B, 0xB7 },
    { 0x0381, 0x01 },
    { 0x0383, 0x01 },
    { 0x0385, 0x01 },
    { 0x0387, 0x01 },
    { 0x0900, 0x01 },
    { 0x0901, 0x22 },
    { 0x0902, 0x00 },
    { 0x3000, 0x75 },
    { 0x3001, 0x00 },
    { 0x305C, 0x11 },
    { 0x3A20, 0x08 },
    { 0x3A21, 0x58 },
    /* Output Size Settings*/
    { 0x0112, 0x0A },
    { 0x0113, 0x0A },
    { 0x034C, 0x08 },
    { 0x034D, 0x58 },
    { 0x034E, 0x04 },
    { 0x034F, 0xB2 },
    { 0x0401, 0x02 },
    { 0x0404, 0x00 },
    { 0x0405, 0x14 },
    { 0x0408, 0x00 },
    { 0x0409, 0x00 },
    { 0x040A, 0x00 },
    { 0x040B, 0x00 },
    { 0x040C, 0x0A },
    { 0x040D, 0x70 },
    { 0x040E, 0x05 },
    { 0x040F, 0xE0 },
    /* Clock Settings*/
    { 0x0301, 0x04 },
    { 0x0303, 0x02 },
    { 0x0305, 0x04 },
    { 0x0306, 0x00 },
    { 0x0307, 0x61 },
    { 0x0309, 0x0A },
    { 0x030B, 0x01 },
    { 0x030D, 0x0C },
    { 0x030E, 0x00 },
    { 0x030F, 0xC8 },
    { 0x0310, 0x01 },
    /* Data Rate Settings*/
    { 0x0820, 0x06 },
    { 0x0821, 0x40 },
    { 0x0822, 0x00 },
    { 0x0823, 0x00 },
    /* Integration Time Settings*/
    { 0x0202, 0x06 },
    { 0x0203, 0x40 },
    { 0x0224, 0x01 },
    { 0x0225, 0xF4 },
    /* Gain Settings*/
    { 0x0204, 0x01 },
    { 0x0205, 0xC0 },
    { 0x0216, 0x00 },
    { 0x0217, 0x00 },
    { 0x020E, 0x01 },
    { 0x020F, 0x00 },
    { 0x0210, 0x01 },
    { 0x0211, 0x00 },
    { 0x0212, 0x01 },
    { 0x0213, 0x00 },
    { 0x0214, 0x01 },
    { 0x0215, 0x00 },
    /* Analog Settings*/
    { 0x45AB, 0x02 },
    { 0x4614, 0x02 },
    /* PAF Settings*/
    { 0x697D, 0x3F },
    { 0x6985, 0x3F },
    { 0x698D, 0x3F },
    { 0x6995, 0x3F },
    { 0x699D, 0x3F },
    { 0x69A5, 0x3F },
    { 0x69AD, 0x3F },
    { 0x69B5, 0x3F },
    /* STATS Settings*/
    { 0x3011, 0x00 },
    { 0x3013, 0x01 },
    /* MIPI Global Timing Settings*/
    { 0x080A, 0x00 },
    { 0x080B, 0x97 },
    { 0x080C, 0x00 },
    { 0x080D, 0x5F },
    { 0x080E, 0x00 },
    { 0x080F, 0x97 },
    { 0x0810, 0x00 },
    { 0x0811, 0x57 },
    { 0x0812, 0x00 },
    { 0x0813, 0x57 },
    { 0x0814, 0x00 },
    { 0x0815, 0x5F },
    { 0x0816, 0x01 },
    { 0x0817, 0x67 },
    { 0x0818, 0x00 },
    { 0x0819, 0x47 },
};

#if 0  /* TODO: debug this resolution */
static const struct cam_i2c_reg_array res1_array[] = {
    /* Mode A1: 5344x4016 Full 24fps */
    /* Preset Settings*/
    { 0x9004, 0x00 },
    { 0x9005, 0x00 },
    /* Mode Settings*/
    { 0x0114, 0x03 },
    { 0x0220, 0x00 },
    { 0x0221, 0x11 },
    { 0x0222, 0x01 },
    { 0x0340, 0x10 },
    { 0x0341, 0x36 },
    { 0x0342, 0x17 },
    { 0x0343, 0x88 },
    { 0x0344, 0x00 },
    { 0x0345, 0x00 },
    { 0x0346, 0x00 },
    { 0x0347, 0x00 },
    { 0x0348, 0x14 },
    { 0x0349, 0xDF },
    { 0x034A, 0x0F },
    { 0x034B, 0xAF },
    { 0x0381, 0x01 },
    { 0x0383, 0x01 },
    { 0x0385, 0x01 },
    { 0x0387, 0x01 },
    { 0x0900, 0x00 },
    { 0x0901, 0x11 },
    { 0x0902, 0x00 },
    { 0x3000, 0x75 },
    { 0x3001, 0x00 },
    { 0x305C, 0x11 },
    { 0x3A20, 0x14 },
    { 0x3A21, 0xE0 },
    /* Output Size Settings*/
    { 0x0112, 0x0A },
    { 0x0113, 0x0A },
    { 0x034C, 0x14 },
    { 0x034D, 0xE0 },
    { 0x034E, 0x0F },
    { 0x034F, 0xB0 },
    { 0x0401, 0x00 },
    { 0x0404, 0x00 },
    { 0x0405, 0x10 },
    { 0x0408, 0x00 },
    { 0x0409, 0x00 },
    { 0x040A, 0x00 },
    { 0x040B, 0x00 },
    { 0x040C, 0x14 },
    { 0x040D, 0xE0 },
    { 0x040E, 0x0F },
    { 0x040F, 0xB0 },
    /* Clock Settings*/
    { 0x0301, 0x04 },
    { 0x0303, 0x02 },
    { 0x0305, 0x04 },
    { 0x0306, 0x00 },
    { 0x0307, 0xC8 },
    { 0x0309, 0x0A },
    { 0x030B, 0x01 },
    { 0x030D, 0x0C },
    { 0x030E, 0x02 },
    { 0x030F, 0xC6 },
    { 0x0310, 0x01 },
    /* Data Rate Settings*/
    { 0x0820, 0x16 },
    { 0x0821, 0x30 },
    { 0x0822, 0x00 },
    { 0x0823, 0x00 },
    /* Integration Time Settings*/
    { 0x0202, 0x10 },
    { 0x0203, 0x2C },
    { 0x0224, 0x01 },
    { 0x0225, 0xF4 },
    /* Gain Settings*/
    { 0x0204, 0x00 },
    { 0x0205, 0x00 },
    { 0x0216, 0x00 },
    { 0x0217, 0x00 },
    { 0x020E, 0x01 },
    { 0x020F, 0x00 },
    { 0x0210, 0x01 },
    { 0x0211, 0x00 },
    { 0x0212, 0x01 },
    { 0x0213, 0x00 },
    { 0x0214, 0x01 },
    { 0x0215, 0x00 },
    /* Analog Settings*/
    { 0x45AB, 0x04 },
    { 0x4614, 0x00 },
    /* PAF Settings*/
    { 0x697D, 0x02 },
    { 0x6985, 0x02 },
    { 0x698D, 0x0B },
    { 0x6995, 0x0B },
    { 0x699D, 0x16 },
    { 0x69A5, 0x16 },
    { 0x69AD, 0x1F },
    { 0x69B5, 0x1F },
    /* STATS Settings*/
    { 0x3011, 0x00 },
    { 0x3013, 0x01 },
    /* MIPI Global Timing Settings*/
    { 0x080A, 0x00 },
    { 0x080B, 0x97 },
    { 0x080C, 0x00 },
    { 0x080D, 0x5F },
    { 0x080E, 0x00 },
    { 0x080F, 0x97 },
    { 0x0810, 0x00 },
    { 0x0811, 0x57 },
    { 0x0812, 0x00 },
    { 0x0813, 0x57 },
    { 0x0814, 0x00 },
    { 0x0815, 0x5F },
    { 0x0816, 0x01 },
    { 0x0817, 0x67 },
    { 0x0818, 0x00 },
    { 0x0819, 0x47 },
};
#endif

static const struct cam_i2c_reg_setting frmival_res0_user_data = {
    .size = ARRAY_SIZE(res0_array),
    .regs = res0_array,
};

//frame rate for 2627x2008
static const struct camera_ext_frmival_node frmival_res0[] = {
    {
        .numerator = 1,
        .denominator = 30,
        .user_data = &frmival_res0_user_data,
    },
};

#if 0
static const struct cam_i2c_reg_setting frmival_res1_user_data = {
    .size = ARRAY_SIZE(res1_array),
    .regs = res1_array,
};

//frame rate for 5340 x 4016
static const struct camera_ext_frmival_node frmival_res1[] = {
    {
        .numerator = 1,
        .denominator = 24,
        .user_data = &frmival_res1_user_data,
    },
};
#endif

// frame sizes for BGGR10
static const struct camera_ext_frmsize_node imx230_cam_frmsizes[] = {
    {
        .width = 2136,
        .height = 1202,
        .num_frmivals = ARRAY_SIZE(frmival_res0),
        .frmival_nodes = frmival_res0,
    },
#if 0
    {
        .width = 5304,
        .height = 4016,
        .num_frmivals = ARRAY_SIZE(frmival_res1),
        .frmival_nodes = frmival_res1,
    },
#endif
};

// format for camera input
static const struct camera_ext_format_node imx230_cam_formats[] = {
    {
        .name = "RGGB10",
        .fourcc = V4L2_PIX_FMT_SRGGB10,
        .depth = 10,
        .num_frmsizes = ARRAY_SIZE(imx230_cam_frmsizes),
        .frmsize_nodes = imx230_cam_frmsizes,
    },
};

// imx230 input
static const struct camera_ext_input_node imx230_inputs[] = {
    {
        .name = "csi-imx230",
        .type = CAM_EXT_INPUT_TYPE_CAMERA,
        .status = 0,
        .capabilities = CAMERA_EXT_STREAM_CAP_PREVIEW |
                        CAMERA_EXT_STREAM_CAP_VIDEO |
                        CAMERA_EXT_STREAM_CAP_SNAPSHOT,
        .num_formats = ARRAY_SIZE(imx230_cam_formats),
        .format_nodes = imx230_cam_formats,
    },
};

//root node
const struct camera_ext_format_db mhb_camera_format_db = {
    .num_inputs = ARRAY_SIZE(imx230_inputs),
    .input_nodes = imx230_inputs,
};

extern struct camera_ext_ctrl_db mhb_camera_ctrl_db;

struct mhb_cdsi_config mhb_camera_csi_config =
{
    .direction = 0,
    .mode = 0x01,            /* TSB_CDSI_MODE_CSI */

    .tx_num_lanes = 4,
    .rx_num_lanes = 0,       /* variable */
    .tx_bits_per_lane = 0,  /* variable */
    .rx_bits_per_lane = 0,  /* variable */

    .hs_rx_timeout = 0xffffffff,

    .framerate = 0, /* variable */

    .pll_frs = 0,
    .pll_prd = 0,
    .pll_fbd = 26,

    .width = 0,  /* variable */
    .height = 0, /* variable */
    .bpp = 0,    /* variable */

    .bta_enabled = 0,
    .continuous_clock = 0,
    .blank_packet_enabled = 0,
    .video_mode = 0,
    .color_bar_enabled = 0,
};

/* Device Ops */
int imx230_get_csi_config(struct device *dev,
                       void *config)
{
    const struct camera_ext_format_user_config *cfg = camera_ext_get_user_config();
    const struct camera_ext_frmival_node *ival;

    ival = get_current_frmival_node(&mhb_camera_format_db, cfg);
    if (ival == NULL) {
        CAM_ERR("Failed to get current frame interval\n");
        return -1;
    }

    mhb_camera_csi_config.rx_num_lanes = 4;
    mhb_camera_csi_config.framerate = roundf((float)(ival->denominator) /
                                             (float)(ival->numerator));
    mhb_camera_csi_config.tx_bits_per_lane = 500000000;
    mhb_camera_csi_config.rx_bits_per_lane = 500000000;

    *(struct mhb_cdsi_config **)config = &mhb_camera_csi_config;

    return 0;
}

int imx230_soc_enable(struct device *dev, uint8_t bootmode)
{
    gpio_direction_out(s_data.dvdd_en, 1);
    gpio_direction_out(s_data.areg_en, 1);
    usleep(CAMERA_POWER_DELAY_US);

    gpio_direction_out(s_data.rst_n, 1);
    usleep(CAMERA_POWER_DELAY_US);

    uint8_t id0 = 0;
    uint8_t id1 = 0;
    mhb_camera_i2c_write_reg1_16(CAMERA_SENSOR_I2C_ADDR, 0x0103, 1);
    mhb_camera_i2c_read_reg1_16(CAMERA_SENSOR_I2C_ADDR, 0x0016, &id0);
    mhb_camera_i2c_read_reg1_16(CAMERA_SENSOR_I2C_ADDR, 0x0017, &id1);
    lldbg("Sensor ID: %02x %02x\n", id0, id1);

    /* configure init registers */
    size_t num = ARRAY_SIZE(init_reg_array);
    int i;
    int ret;
    for (i = 0; i < num; i++) {
        ret = mhb_camera_i2c_write_reg1_16(CAMERA_SENSOR_I2C_ADDR,
                                        init_reg_array[i].reg_addr,
                                        init_reg_array[i].data);
        if (ret)
            break;
    }
    return ret;
}

int imx230_soc_disable(struct device *dev)
{
    gpio_direction_out(s_data.rst_n, 0);
    gpio_direction_out(s_data.dvdd_en, 0);
    gpio_direction_out(s_data.areg_en, 0);

    usleep(CAMERA_POWER_DELAY_US);

    return 0;
}

int imx230_stream_configure(struct device *dev)
{
    int i;
    int ret;
    const struct camera_ext_format_user_config *cfg = camera_ext_get_user_config();
    const struct camera_ext_frmival_node *ival;

    ival = get_current_frmival_node(&mhb_camera_format_db, cfg);
    if (ival == NULL) {
        CAM_ERR("Failed to get current frame interval\n");
        return -1;
    }


    const struct cam_i2c_reg_setting *udata = ival->user_data;
    if (udata == NULL) {
        CAM_ERR("Failed to get user data\n");
        return -1;
    }

    for (i = 0; i < udata->size; i++) {
        ret = mhb_camera_i2c_write_reg1_16(CAMERA_SENSOR_I2C_ADDR,
                                        udata->regs[i].reg_addr,
                                        udata->regs[i].data);
        if (ret)
            break;
    }

    return ret;
}

int imx230_stream_enable(struct device *dev)
{
    int ret = start_metadata_task();
    if (!ret) {
        ret = mhb_camera_i2c_write_reg1_16(CAMERA_SENSOR_I2C_ADDR, 0x0100, 0x01);
        if (ret)
            stop_metadata_task();
    }

    return ret;
}

int imx230_stream_disable(struct device *dev)
{
    stop_metadata_task();
    return mhb_camera_i2c_write_reg1_16(CAMERA_SENSOR_I2C_ADDR, 0x0100, 0x00);
}

static int _dev_probe(struct device *dev)
{
    struct device_resource *res;

    memset(&s_data, 0, sizeof(s_data));

    res = device_resource_get_by_name(dev, DEVICE_RESOURCE_TYPE_GPIO, "rst_n");
    if (!res) {
        CAM_ERR("failed to get rst_n gpio\n");
        return -ENODEV;
    }
    s_data.rst_n = res->start;

    res = device_resource_get_by_name(dev, DEVICE_RESOURCE_TYPE_GPIO, "dvdd_en");
    if (!res) {
        CAM_ERR("failed to get dvdd_en gpio\n");
        return -ENODEV;
    }
    s_data.dvdd_en = res->start;

    res = device_resource_get_by_name(dev, DEVICE_RESOURCE_TYPE_GPIO, "areg_en");
    if (!res) {
        CAM_ERR("failed to get areg_en gpio\n");
        return -ENODEV;
    }
    s_data.areg_en = res->start;

    res = device_resource_get_by_name(dev, DEVICE_RESOURCE_TYPE_GPIO, "spi_sel");
    if (!res) {
        CAM_ERR("failed to get spi_sel gpio\n");
        return -ENODEV;
    }
    s_data.spi_sel = res->start;

    gpio_direction_out(s_data.spi_sel, 0);
    gpio_direction_out(s_data.rst_n, 0);
    gpio_direction_out(s_data.dvdd_en, 0);
    gpio_direction_out(s_data.areg_en, 0);

    camera_ext_register_format_db(&mhb_camera_format_db);
    camera_ext_register_control_db(&mhb_camera_ctrl_db);
    init_metadata_task();

    return 0;
}

static struct device_mhb_camera_dev_type_ops mhb_camera_type_ops = {
    .soc_enable = imx230_soc_enable,
    .soc_disable = imx230_soc_disable,
    .stream_configure = imx230_stream_configure,
    .stream_enable = imx230_stream_enable,
    .stream_disable = imx230_stream_disable,
    .get_csi_config = imx230_get_csi_config,
};

static struct device_driver_ops imx230_driver_ops = {
    .probe    = _dev_probe,
    .type_ops = &mhb_camera_type_ops,
};

struct device_driver imx230_mhb_camera_driver = {
    .type = DEVICE_TYPE_MHB_CAMERA_HW,
    .name = "Sony",
    .desc = "IMX230 MHB Camera",
    .ops  = &imx230_driver_ops,
};
